<!DOCTYPE html>
<html>
	<head>
		<title>Canvas Test2</title>
		<script>
			//canvasの中身を指し示すもの
			let ctx;
			//canvasのwidth 幅
			let cw;
			//canvasのheight 高さ
			let ch;
			
			//パーティクルの準備
			const density = 100; //パーティクルの密度
			let particles = [];
			
			const density_line = 10;
			let lines = [];
			
			const density_tri = 10;
			let tris = [];
			
			//初期化処理
			function init(){
				//IDがmycanvasのものをcanvasという変数にいれておく
				let canvas = document.getElementById('mycanvas');
				//canvasが存在しないか、canvasの中身がなければ処理終了
				if(!canvas ||!canvas.getContext){
					return false;
				}
				
				//canvasの中身を指し示すものを代入
				ctx = canvas.getContext('2d');
				//canvasの幅・高さを代入しておく
				cw = canvas.width;
				ch = canvas.height;
				
				//円の初期化
				for(let i=0;i < density; i++){
					particles[i] = new Particle(getRandomScale(), "rgba("+getRandomColor()+","+getRandomColor()+","+getRandomColor()+","+getRandomAlpha()+")", getRandomVelocity(), getRandomVelocity(), 1);
					particles[i].position.x = cw/2;
					particles[i].position.y = ch/4;
					particles[i].draw();			
				}
				//線の初期化
				for(let j=0;j < density_line; j++){
					lines[j] = new Line(getRandomX(), getRandomY(), getRandomVelocity(), getRandomVelocity(),getRandomX(), getRandomY(), getRandomVelocity(), getRandomVelocity(),"rgba("+getRandomColor()+","+getRandomColor()+","+getRandomColor()+","+getRandomAlpha()+")",getRandomWidth(), 1);
					lines[j].draw();
				}
				//三角形の初期化
				for(let k=0;k<density_tri;k++){
					tris[k] = new Tri(getRandomX(), getRandomY(), getRandomVelocity(), getRandomVelocity(),getRandomX(), getRandomY(), getRandomVelocity(), getRandomVelocity(),getRandomX(), getRandomY(), getRandomVelocity(), getRandomVelocity(),"rgba("+getRandomColor()+","+getRandomColor()+","+getRandomColor()+","+getRandomAlpha()+")",getRandomWidth(), 1);
					tris[k].draw();
				}
				
				//実際の描画処理
				draw();
				
				//一定時間ごとに書き換える
				setInterval("draw()",33);
			}
			
			//Particleクラス
			class Particle {
				constructor(scale, color, vx, vy, gv){
					this.scale = scale;
					this.color = color;
					this.vx = vx;
					this.vy = vy;
					this.gv = gv;
					this.position = {
						x: 100,
						y: 100
					};
				}
				draw(){
					ctx.beginPath();
					ctx.arc(this.position.x, this.position.y, this.scale, 0, 2*Math.PI, false);
					ctx.fillStyle = this.color;
					ctx.fill();
				}
				update(){
					this.vy += this.gv;
					this.position.x += this.vx;
					this.position.y += this.vy;
					this.draw();
					if(this.position.x > cw) this.position.x -= cw;
					if(this.position.y > ch) this.vy = -this.vy;
				}
			}

			//Lineクラス
			class Line {
				constructor(x1, y1, vx1, vy1, x2, y2, vx2, vy2, color, width, gv){
					this.position1 = {x:x1, y:y1};
					this.v1 = {x:vx1, y:vy1};
					this.position2 = {x:x2, y:y2};
					this.v2 = {x:vx2, y:vy2};
					this.color = color;
					this.width = width;
					this.gv = gv;
				}
				draw(){
					ctx.strokeStyle = this.color;
					ctx.lineWidth = this.width;
					ctx.beginPath();
					ctx.moveTo(this.position1.x, this.position1.y);
					ctx.lineTo(this.position2.x, this.position2.y);
					ctx.stroke();
				}
				update(){
					this.v1.y += this.gv;
					this.v2.y += this.gv;
					this.position1.x += this.v1.x;
					this.position1.y += this.v1.y;
					this.position2.x += this.v2.x;
					this.position2.y += this.v2.y;
					this.draw();
					if(this.position1.y > ch) this.v1.y = -this.v1.y;
					if(this.position2.y > ch) this.v2.y = -this.v2.y;
				}
			}
			
			class Tri {
				constructor(x1, y1, vx1, vy1, x2, y2, vx2, vy2, x3, y3, vx3, vy3, color, width, gv){
					this.position1 = {x:x1, y:y1};
					this.v1 = {x:vx1, y:vy1};
					this.position2 = {x:x2, y:y2};
					this.v2 = {x:vx2, y:vy2};
					this.position3 = {x:x3, y:y3};
					this.v3 = {x:vx3, y:vy3};
					this.color = color;
					this.width = width;
					this.gv = gv;
				}
				draw(){
					ctx.strokeStyle = this.color;
					ctx.lineWidth = this.width;
					ctx.beginPath();
					ctx.moveTo(this.position1.x, this.position1.y);
					ctx.lineTo(this.position2.x, this.position2.y);
					ctx.lineTo(this.position3.x, this.position3.y);
					ctx.lineTo(this.position1.x, this.position1.y);
					ctx.stroke();
				}
				update(){
					this.v1.y += this.gv;
					this.v2.y += this.gv;
					this.v3.y += this.gv;
					this.position1.x += this.v1.x;
					this.position1.y += this.v1.y;
					this.position2.x += this.v2.x;
					this.position2.y += this.v2.y;
					this.position3.x += this.v3.x;
					this.position3.y += this.v3.y;
					this.draw();
					if(this.position1.y > ch) this.v1.y = -this.v1.y;
					if(this.position2.y > ch) this.v2.y = -this.v2.y;
					if(this.position3.y > ch) this.v3.y = -this.v3.y;
				}
			}
			
			function draw(){
				//画面をリセットする
				ctx.fillStyle = "rgba(255,255,255,1)";
				ctx.fillRect(0,0,cw,ch);
				
				//円の描画
				for(let i=0;i < density; i++){
					particles[i].update();
				}
				
				//線の描画
				for(let j=0;j < density_line; j++){
					lines[j].update();
				}
				//三角形の描画
				for(let k=0;k < density_tri; k++){
					tris[k].update();
				}
			}

			function getRandomColor(){
				return Math.floor(Math.random()*255);
			}
			function getRandomAlpha(){
				return Math.random();
			}
			function getRandomScale(){
				return (Math.random()*(8-3))+3;
			}
			function getRandomX(){
				return Math.random()*cw;
			}
			function getRandomY(){
				return Math.random()*ch;
			}
			function getRandomWidth(){
				return Math.random()*10;
			}
			function getRandomVelocity(){
				return Math.random()*20-10;
			}
		</script>
	</head>
	<body onload="init();">
		<H1>Canvas Test</H1>
		<canvas id="mycanvas" width="1000" height="800"></canvas>
	</body>
</html>